package  {		import flash.display.MovieClip;	import flash.events.MouseEvent;	import TrackerEvent;	import com.nocircleno.graffiti.tools.BrushTool;	import flash.geom.Point;	import flash.display.Shape;	import flash.events.Event;	import flash.display.BitmapData;	import flash.display.Bitmap;	import mirrorCanvas;	import flash.display.Sprite;	import flash.filesystem.File;	import flash.display.StageDisplayState;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.system.System;	import com.nestor.elements.kiosk;	import flash.desktop.NativeApplication;	import com.greensock.TweenLite;	import flash.media.SoundChannel;	import flash.media.Sound;	import flash.ui.Mouse;	import flash.events.KeyboardEvent;		public class clownGui extends MovieClip {		private var sc:SoundChannel;		private var sq:Sound;		private var cfg:XML;		private var alerts:Object = new Object();		private var cur;		private var bin:File;		var remote:TrackerRemote;		public var mirr:mirrorCanvas;		public var tools:toolBox;		public var pal:palette;		public var al:alert;		public var meta:metaTools;		private var pad=10;		private var time:int = 3;		public var nativeApp:NativeApplication = NativeApplication.nativeApplication;		private var isAttract:Boolean;		private var arr:Bitmap;		private var mouseHidden:Boolean = false;		public function clownGui() {			stage.addEventListener(Event.ACTIVATE, active);			var ldr:URLLoader = new URLLoader();			var url:URLRequest = new URLRequest("gui_config.xml");			ldr.addEventListener(Event.COMPLETE, configLoaded);			ldr.load(url);			sq = new sqMP3();			arr = new Bitmap(new arrowBMD());			mirr = new mirrorCanvas();			bin = File.createTempDirectory();						// constructor code						tools = new toolBox();						pal = new palette();			meta = new metaTools();			mirr.metaTools = meta;			mirr.toolBox = tools;			mirr.bin = bin;			tools.palette = pal;2						//stack left			tools.x=0+pad;			addChild(tools);			mirr.x = tools.x + tools.width+pad;			addChild(mirr);						pal.x = meta.x = mirr.x + mirr.width+pad;			addChild(meta);						pal.y = meta.y + meta.height+pad;			addChild(pal);						al= new alert();						al.evTarget = this;			mirr.addChildAt(al,4);			al.addEventListener(AlertEvent.ACTION, alertAction);						mirr.addEventListener(ClownEvent.DRAW_DONE, drawDone);						remote = new TrackerRemote();			remote.bin = bin;			remote.addEventListener(TrackerEvent.IMAGE_SAVED, imageSaved);			remote.addEventListener(TrackerEvent.FACE_RECT, faceRect);			//stage.addEventListener(MouseEvent.MOUSE_DOWN, testSend);			meta.addEventListener(ToolEvent.SNAP_PIC, snapPic);			stage.addEventListener(KeyboardEvent.KEY_DOWN,keyHandler);			attract();//			stage.displayState = StageDisplayState.FULL_SCREEN_INTERACTIVE;			mouseToggle();					}				private function attract():void{			mirr.reset();			meta.reset();			arr.rotationX = -90;						remote.sendCommand("attract","now");			addChild(arr);			TweenLite.to(arr,1.5,{rotationX:0});						isAttract = true;					}						private function attractOff():void{			sc = sq.play();			TweenLite.to(arr,1.5,{rotationX:-90, onComplete:attractOffComplete});					}		private function attractOffComplete():void{			removeChild(arr);		}								private function configLoaded(e:Event):void{			e.target.removeEventListener(Event.COMPLETE, configLoaded);			cfg = new XML(e.target.data);			var list:XMLList = cfg.PROMPTS.PROMPT;			trace(list[0]);			for each (var node:XML in list){				var oNode:Object = new Object();				oNode.text = node.toXMLString();				oNode.type = Number(node.@type.toString());				oNode.time = Number(node.@time.toString());				oNode.id = node.@id.toString();				oNode.confirmed = Boolean(false);				alerts[oNode.id] = oNode;			}						var offX:Number = cfg.SCREEN.OFFX.toString();			var offY:Number = cfg.SCREEN.OFFY.toString();			var isFull:Boolean = (cfg.SCREEN.FULLSCREEN.toString() == 1) ? true : false;			var full:String = (isFull) ? StageDisplayState.FULL_SCREEN_INTERACTIVE :StageDisplayState.NORMAL;			stage.nativeWindow.x = offX;			stage.nativeWindow.y = offY;			stage.displayState = full;						time = cfg.SCREEN.TIMEOUT;									System.disposeXML( cfg );			list = null;			cfg = null;		}				private function active(e:Event):void{			enableTimeout();		}				public function enableTimeout():void		{			NativeApplication.nativeApplication.idleThreshold = time;			NativeApplication.nativeApplication.addEventListener(Event.USER_IDLE, timeoutHandler);			trace("Timeout ON");		}						private function timeoutHandler(e:Event):void{			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.timeout));		}				private function reset():void{			//pal = new palette();						attract();		}				private function testSend(m:MouseEvent):void{			var ms:String = m.localX+","+m.localY;			remote.queueCommand("mouseMoved", ms);			remote.sendCommands();			trace(m.target);					}				private function imageSaved(t:TrackerEvent){			mirr.reset();			var loc:String = String(t.data);			mirr.faceImage = loc;						meta.Undo.isActive = true;			meta.Finish.isActive = true;			meta.Cam.isActive = true;			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.picSnapped));		}				private function faceRect(t:TrackerEvent):void{			mirr.rect = t.data;		}						private function keyHandler(m:KeyboardEvent){			switch (m.charCode){				case 109:					mouseToggle();					break;			}		}				private function mouseToggle():void{			(!mouseHidden) ? Mouse.hide() : Mouse.show();			mouseHidden = !mouseHidden;		}								///ALERTS				private function drawDone(c:ClownEvent):void{			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.drawDone));			sendFace();		}				private function snapPic(e:Event):void{			if(isAttract) {attractOff(); isAttract = false;}			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.snapPic));			requestSnap();		}				//ALERT RESPONSE HANDLERS		private function alertAction(a:AlertEvent){						switch(a.alert.id){				case "snapPic":					break;				case "drawDone":					dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.trackerTip));					break;				case "picSnapped":					dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.paintTip));					break;				case "paintTip":					dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.paintTip2));					break;				case "timeout":					if (!a.alert.confirmed) {						attract();						a.alert.confirmed = false;					}					break;			}		}				private function requestSnap():void{			remote.queueCommand("tmpDir", bin.nativePath);			remote.queueCommand("snap","now");			remote.sendCommands();			mirr.reset();		}				private function sendFace():void{			remote.sendCommand("facePainted", mirr.currentImage);		}	}	}