package  {		import flash.display.MovieClip;	import flash.events.MouseEvent;	import TrackerEvent;	import com.nocircleno.graffiti.tools.BrushTool;	import flash.geom.Point;	import flash.display.Shape;	import flash.events.Event;	import flash.display.BitmapData;	import flash.display.Bitmap;	import mirrorCanvas;	import flash.display.Sprite;	import flash.filesystem.File;	import flash.display.StageDisplayState;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.system.System;		public class clownGui extends MovieClip {		private var cfg:XML;		private var alerts:Object = new Object();		private var cur;		private var bin:File;		var remote:TrackerRemote;		public var mirr:mirrorCanvas;		public var tools:toolBox;		public var pal:palette;		public var al:alert;		public var meta:metaTools;		private var pad=10;		public function clownGui() {			var ldr:URLLoader = new URLLoader();			var url:URLRequest = new URLRequest("config.xml");			ldr.addEventListener(Event.COMPLETE, configLoaded);			ldr.load(url);								mirr = new mirrorCanvas();			bin = File.createTempDirectory();						// constructor code						tools = new toolBox();						pal = new palette();			meta = new metaTools();			mirr.metaTools = meta;			mirr.toolBox = tools;			mirr.bin = bin;			tools.palette = pal;2						//stack left			tools.x=0+pad;			addChild(tools);			mirr.x = tools.x + tools.width+pad;			addChild(mirr);						pal.x = meta.x = mirr.x + mirr.width+pad;			addChild(meta);						pal.y = meta.y + meta.height+pad;			addChild(pal);						al= new alert();			al.evTarget = this;			addChild(al);			al.addEventListener(AlertEvent.ACTION, alertAction);						mirr.addEventListener(ClownEvent.DRAW_DONE, drawDone);						remote = new TrackerRemote();			remote.bin = bin;			remote.addEventListener(TrackerEvent.IMAGE_SAVED, imageSaved);			remote.addEventListener(TrackerEvent.FACE_RECT, faceRect);			//stage.addEventListener(MouseEvent.MOUSE_DOWN, testSend);			meta.addEventListener(ToolEvent.SNAP_PIC, snapPic);//			stage.displayState = StageDisplayState.FULL_SCREEN_INTERACTIVE;								}				private function configLoaded(e:Event):void{			e.target.removeEventListener(Event.COMPLETE, configLoaded);			cfg = new XML(e.target.data);			var list:XMLList = cfg.PROMPTS.PROMPT;			trace(list[0]);			for each (var node:XML in list){				var oNode:Object = new Object();				oNode.text = node.toXMLString();				oNode.type = Number(node.@type.toString());				oNode.time = Number(node.@time.toString());				oNode.id = node.@id.toString();				oNode.confirmed = Boolean(false);				alerts[oNode.id] = oNode;			}						var offX:Number = cfg.SCREEN.OFFX.toString();			var offY:Number = cfg.SCREEN.OFFY.toString();			var isFull:Boolean = (cfg.SCREEN.FULLSCREEN.toString() == 1) ? true : false;			var full:String = (isFull) ? StageDisplayState.FULL_SCREEN_INTERACTIVE :StageDisplayState.NORMAL;			stage.nativeWindow.x = offX;			stage.nativeWindow.y = offY;			stage.displayState = full;						System.disposeXML( cfg );			list = null;			cfg = null;		}								private function testSend(m:MouseEvent):void{			var ms:String = m.localX+","+m.localY;			remote.queueCommand("mouseMoved", ms);			remote.sendCommands();			trace(m.target);					}				private function imageSaved(t:TrackerEvent){			mirr.reset();			var loc:String = String(t.data);			mirr.faceImage = loc;						meta.Undo.isActive = true;			meta.Finish.isActive = true;			meta.Cam.isActive = true;			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.picSnapped));		}				private function faceRect(t:TrackerEvent):void{			mirr.rect = t.data;		}												///ALERTS				private function drawDone(c:ClownEvent):void{			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.drawDone));		}				private function snapPic(e:Event):void{			dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.snapPic));		}				//ALERT RESPONSE HANDLERS		private function alertAction(a:AlertEvent){						switch(a.alert.id){				case "snapPic":					requestSnap();					break;				case "drawDone":					sendFace();					break;				case "picSnapped":					dispatchEvent(new AlertEvent(AlertEvent.ALERT,false,false,alerts.paintTip));					break;			}		}				private function requestSnap():void{			remote.queueCommand("snap","now");			remote.sendCommands();			mirr.reset();		}				private function sendFace():void{			remote.sendCommand("facePainted", mirr.currentImage);		}	}	}