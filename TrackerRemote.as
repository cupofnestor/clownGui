package  {	import flash.net.DatagramSocket;	import flash.events.DatagramSocketDataEvent;								import flash.utils.ByteArray;	import TrackerEvent;				import FaceLayer;	import flash.events.Event;			import flash.events.EventDispatcher;	import flash.filesystem.File;			public class TrackerRemote extends EventDispatcher{		static const COM_DEL:String = "[c]";		static const ARG_DEL:String = "::";		var _bin:String = null;		var recSocket,sendSocket:DatagramSocket;		var portSend:Number;		var commands:String = new String();				public function TrackerRemote(_portSend:Number = 11999,_portRec:Number = 12000) {			// constructor code			setupRec(_portRec);			setupSend(_portSend);		}				public function set bin(f:File):void		{			_bin = f.nativePath; //use nativepath for OF		}				private function setupRec(portRec){			recSocket = new DatagramSocket();			clearBinding(recSocket);			recSocket.bind(parseInt(portRec), "127.0.0.1" );			recSocket.addEventListener(DatagramSocketDataEvent.DATA, dataReceived);			recSocket.receive();		}				private function setupSend(_portSend){			//clearBinding(sendSocket);			portSend = _portSend;			sendSocket = new DatagramSocket();		}		private function dataReceived(e:DatagramSocketDataEvent):void{			var cs:String = e.data.readUTFBytes( e.data.bytesAvailable );			var recComs:Array = cs.split(COM_DEL);			trace(cs);			recComs.pop();			if(recComs.length > 0){				for each (var command:String in recComs){					var cmdArr:Array = command.split(ARG_DEL);					(cmdArr.length > 1) ? parseCommand(cmdArr[0],cmdArr[1]) :parseCommand(cmdArr[0],cmdArr[1]) ;				}			}		}				private function parseCommand(command:String, argument:String = ""):void{			switch (command){				case "imageSaved":					trace("imageSaved");					dispatchEvent(new TrackerEvent(TrackerEvent.IMAGE_SAVED,false,true,argument));					break;				case "faceRect":					trace("faceRect");					dispatchEvent(new TrackerEvent(TrackerEvent.FACE_RECT,false,true,argument));					break;				case "reqTmpDir":					sendCommand("tmpDir", _bin);					break;			}		}				private function send(m:String):void		{			trace("attempting to send "+m);			var data:ByteArray = new ByteArray;			data.writeUTFBytes(m);						try{								sendSocket.send(data,0,0,"127.0.0.1",portSend);			}catch(error:Error){				trace(error.message);			}		}				public function sendCommand(command:String, argument:String = ""):void{			queueCommand(command,argument);			sendCommands();		}				public function queueCommand(command:String, argument:String = "" ):void{			var cmd:String = command+ARG_DEL+argument+COM_DEL;			commands+=cmd;		}				public function sendCommands():void{			send(commands);			commands = new String();		}						private function clearBinding(s:DatagramSocket){			if (s.bound){				s.close();				s = new DatagramSocket;			}		}	}	}